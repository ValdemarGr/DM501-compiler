//
// Created by valde on 3/25/19.
//

#ifndef HELLO_CONSTS_H
#define HELLO_CONSTS_H

#include "../utils/map.h"

#define ASM_HEADER "main:\n\tpush %%rbp\nmov %%rbp, %%rax\n\tmovq %%rsp, %%rbp\npush %%rax\n"
#define ASM_TAIL "mov $60, %%rax\nmov $0, %%rdi\nsyscall\n"
#define MAIN_HEADER "\t# 20 mb\r\n\r\n    mov $0, %%rdi\r\n    mov $12, %%rax\r\n    syscall\r\n    #move heap into one\r\n    leaq gcHeapOne, %%r15\r\n    movq %%rax, 24(%%r15)\r\n    movq $10000, 16(%%r15)\r\n    movq $0, 8(%%r15)\r\n    movq $1, 0(%%r15)\r\n    addq $10000, %%rax\r\n    push %%rax\r\n    movq %%rax, %%rdi\r\n    mov $12, %%rax\r\n    syscall\r\n    pop %%rax\r\n    #top should be in rax\r\n\r\n    #move heap into one\r\n\r\n    leaq gcHeapTwo, %%r15\r\n    movq %%rax, 24(%%r15)\r\n    movq $10000, 16(%%r15)\r\n    movq $0, 8(%%r15)\r\n    movq $0, 0(%%r15)\r\n\r\n    addq $10000, %%rax\r\n    movq %%rax, %%rdi\r\n    mov $12, %%rax\r\n    syscall\n"
#define GARBAGE_COLLECTOR_CHUNK "gcHeapOne:\r\n    .space 32\r\ngcHeapTwo:\r\n    .space 32\r\nmetaHashMap:\r\n    .space 16\r\nmetaLambdaList:\r\n    .space 16\r\n.section .text\r\n.global main\r\n.extern printf\r\n# METADATA_BEGIN_BODY_BLOCK\r\n# VAR clsB\r\n# VAR clsA\r\n# METADATA_CREATE_MAIN\r\n.type garbageCollectStructure, @function\r\ngarbageCollectStructure:\r\n    push %%rbp\r\n    movq %%rsp, %%rbp\r\n\tsubq $56, %%rsp\r\n\r\n\r\n\r\n    movq %%rbp,%%rsp\r\n    pop %%rbp\r\n    ret\r\n\r\n.type garbageCollectBFS, @function\r\ngarbageCollectBFS:\r\n    push %%rbp\r\n    movq %%rsp, %%rbp\r\n\r\n    push %%rax\r\n    push %%rcx\r\n    push %%rdx\r\n    push %%rbx\r\n    push %%rsi\r\n    push %%rdi\r\n    push %%r8\r\n    push %%r9\r\n    push %%r10\r\n    push %%r11\r\n    push %%r12\r\n    push %%r13\r\n    push %%r14\r\n    push %%r15\r\n\r\n    #reset heap counter for both &\r\n    # swap in use values\r\n    leaq gcHeapTwo, %%rsi\r\n    negq 0(%%rsi)\r\n    movq $0, 8(%%rsi)\r\n    leaq gcHeapOne, %%rsi\r\n    negq 0(%%rsi)\r\n    movq $0, 8(%%rsi)\r\n\r\n    movq 0(%%rsi), %%r12\r\n    cmp $1, %%r12\r\n    je loadHeapEnd\r\n    leaq gcHeapTwo, %%rsi\r\n    loadHeapEnd:\r\n\r\n\tmov 16(%%rbp), %%r15\r\n    # we will find the amount of ptrs in -16\r\n    mov -16(%%r15), %%r14\r\n    mov %%r14, %%r8\r\n    #add 1 + the size of the array list to begin the fetch phase\r\n    #inc %%r8\r\n    #times 8 because of sizes\r\n    imulq $8, %%r8\r\n\r\n    mov $-24, %%r13 # offset\r\n\r\n    #add initial offset\r\n    movq $0, %%r12\r\n    subq %%r8, %%r12\r\n    movq %%r12, %%r8\r\n\r\n    add %%r13, %%r8\r\n\r\n    #initial pass moves all ptrs over\r\n    gcLoopBegin:\r\n    cmp $0, %%r14\r\n    je gcLoopEnd\r\n        mov (%%r15, %%r13, 1), %%rdi #rdi has offset\r\n        #mul by factor\r\n        imulq $8, %%rdi\r\n        #negate because of stack access\r\n        movq $0, %%r12\r\n        subq %%rdi, %%r12\r\n        movq %%r12, %%rdi\r\n        #add the constant offset\r\n        add %%r8, %%rdi\r\n        #%%r12 is now our offset to our first pointer\r\n        movq (%%r15, %%rdi, 1), %%rcx\r\n\r\n        #nullptr check\r\n        cmp $0, %%rcx\r\n        je gcLoopEpilogue\r\n\r\n        # get size\r\n        mov -8(%%rcx), %%rax\r\n        cmp $-1, %%rax\r\n        jne forLambdaEnd\r\n        forLambda:\r\n            mov $2, %%rax\r\n            jmp skipRec\r\n        forLambdaEnd:\r\n\r\n        #mul by 8 bc pointer size\r\n        imulq $8, %%rax\r\n\r\n        add $8, %%rax\r\n\r\n        #get ptr count\r\n        movq (%%rcx, %%rax, 1), %%rdi\r\n        #add the ptr count slot\r\n        add $8, %%rax\r\n\r\n        cmpq $-1, %%rdi\r\n        je skipRec\r\n            imulq $8, %%rdi\r\n            add %%rdi, %%rax\r\n            #rax now has the structure size\r\n        skipRec:\r\n\r\n        # subtract 8 from rcx to find where to move from\r\n        # reserve new space on heap\r\n\r\n        # new heap struct is in rsi\r\n        # in rcx we have the pointer to the beginning of the struct in old heap\r\n        # in rax we have the length of the struct * 8\r\n        # we have r12 free\r\n        # we have rdi free\r\n\r\n        # save new positional ptr\r\n        movq 24(%%rsi), %%r12 # r12 has new heap start\r\n        movq 8(%%rsi), %%rdi # current heap position\r\n\r\n        #save old heap position\r\n        pushq %%r12\r\n\r\n        add %%rdi, %%r12 # r12 now has current heap pointer\r\n        mov $0, %%rbx # rbx has 0\r\n\r\n        heapMover:\r\n        cmp $0, %%rax\r\n        je heapMoverEnd\r\n\r\n            # move rcx + indexer(rbx) to top of new heap\r\n            movq -8(%%rcx, %%rbx, 1), %%rdx\r\n\r\n            movq %%rdx, (%%r12, %%rdi, 1)\r\n\r\n            add $8, %%rdi\r\n            add $8, %%rbx\r\n            sub $8, %%rax\r\n        jmp heapMover\r\n        heapMoverEnd:\r\n\r\n        mov %%rdi, 8(%%rsi)\r\n\r\n        #Now we have to restore the stack pointer\r\n        #We have old heap start in r12\r\n        popq %%r12\r\n        # we hide size ptr\r\n        addq $8, %%r12\r\n\r\n        mov (%%r15, %%r13, 1), %%rdi #rdi has offset\r\n        #mul by factor\r\n        imulq $8, %%rdi\r\n        #negate because of stack access\r\n        movq $0, %%rax\r\n        subq %%rdi, %%rax\r\n        movq %%rax, %%rdi\r\n        #add the constant offset\r\n        add %%r8, %%rdi\r\n        #r12 is now our offset to our first pointer\r\n        movq %%r12, (%%r15, %%rdi, 1)\r\n\r\n        gcLoopEpilogue:\r\n\r\n        subq $8, %%r13\r\n        dec %%r14\r\n        jmp gcLoopBegin\r\n    gcLoopEnd:\r\n\r\n    # if we are main, quit\r\n    leaq staticLink, %%rcx #used for comparison with main\r\n    mov 0(%%rcx), %%rcx\r\n    cmp %%r15, %%rcx\r\n    je gcRet\r\n\r\n    #recurse\r\n    pushq -8(%%r15)\r\n    call garbageCollectBFS\r\n    pop %%r15\r\n\r\n    gcRet:\r\n\r\n    pop %%r15\r\n    pop %%r14\r\n    pop %%r13\r\n    pop %%r12\r\n    pop %%r11\r\n    pop %%r10\r\n    pop %%r9\r\n    pop %%r8\r\n    pop %%rdi\r\n    pop %%rsi\r\n    pop %%rbx\r\n    pop %%rdx\r\n    pop %%rcx\r\n    pop %%rax\r\n\r\n    movq %%rbp,%%rsp\r\n    pop %%rbp\r\n    ret\r\n\r\n\r\n.type garbageCollect, @function\r\ngarbageCollect:\r\n    push %%rbp\r\n    movq %%rsp, %%rbp\r\n\r\n    pushq 16(%%rbp)\r\n    call garbageCollectBFS\r\n    pop %%rax\r\n\r\n    leaq gcHeapOne, %%r15\r\n    cmp $1, 0(%%r15)\r\n    je heapSelectorEnd\r\n    leaq gcHeapTwo, %%r15\r\n    heapSelectorEnd:\r\n\r\n\r\n\r\n    mov %%rbp,%%rsp\r\n    pop %%rbp\r\n    ret\r\n\r\n.type garbageCollectAllocate, @function\r\ngarbageCollectAllocate:\r\n    push %%rbp\r\n    movq %%rsp, %%rbp\r\n    subq $32, %%rsp\r\n\r\n    push %%r15\r\n    push %%r14\r\n\r\n    #args\r\n    #rbp\r\n    #desired byte size\r\n\r\n    movq 16(%%rbp), %%rax\r\n    movq %%rax, -16(%%rbp)\r\n    movq 24(%%rbp), %%rax\r\n    movq %%rax, -8(%%rbp)\r\n\r\n    leaq gcHeapOne, %%r15\r\n    cmp $1, 0(%%r15)\r\n    je heapSelectorEndAlloc\r\n    leaq gcHeapTwo, %%r15\r\n    heapSelectorEndAlloc:\r\n\r\n    # current heap position\r\n    movq 8(%%r15), %%r14\r\n    # add new size\r\n    movq -8(%%rbp), %%rax\r\n    addq %%r14, %%rax\r\n    movq %%rax, 8(%%r15)\r\n\r\n    # old size is still in r14\r\n    movq 24(%%r15), %%rax\r\n    addq %%r14, %%rax\r\n\r\n    pop %%r14\r\n    pop %%r15\r\n\r\n    mov %%rbp,%%rsp\r\n    pop %%rbp\r\n    ret"

#endif //HELLO_CONSTS_H
